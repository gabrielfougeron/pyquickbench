
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "_build/auto_examples/tutorial/10-TimeTrains.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download__build_auto_examples_tutorial_10-TimeTrains.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr__build_auto_examples_tutorial_10-TimeTrains.py:


Time Trains
===========

.. GENERATED FROM PYTHON SOURCE LINES 7-8

As demonstrated in earlier posts in the tutorial, :mod:`pyquickbench` can be useful to measure the wall time of python functions. More often than not however, it can be useful to have a more precise idea of where cpu cycles are spent. This is the raison d'Ãªtre of :class:`pyquickbench.TimeTrain`. As shown in the following few lines, using a :class:`pyquickbench.TimeTrain` is extremely simple: simply call the :meth:`pyquickbench.TimeTrain.toc` method between snippets of code you want to time and :mod:`pyquickbench` takes care of the rest!

.. GENERATED FROM PYTHON SOURCE LINES 8-13

.. code-block:: Python



    import time
    import pyquickbench








.. GENERATED FROM PYTHON SOURCE LINES 45-66

.. code-block:: Python


    TT = pyquickbench.TimeTrain()

    time.sleep(0.01)
    TT.toc()

    time.sleep(0.02)
    TT.toc()

    time.sleep(0.03)
    TT.toc()

    time.sleep(0.04)
    TT.toc()

    time.sleep(0.01)
    TT.toc()    

    print(TT)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    TimeTrain results:

    0.01001699 s at file 10-TimeTrains.py line 49
    0.02028868 s at file 10-TimeTrains.py line 52
    0.03001066 s at file 10-TimeTrains.py line 55
    0.04002969 s at file 10-TimeTrains.py line 58
    0.01001850 s at file 10-TimeTrains.py line 61

    Total: 0.11036452 s





.. GENERATED FROM PYTHON SOURCE LINES 67-68

Individual calls to :meth:`pyquickbench.TimeTrain.toc` can be named.

.. GENERATED FROM PYTHON SOURCE LINES 68-81

.. code-block:: Python


    TT = pyquickbench.TimeTrain()

    for i in range(3):
        time.sleep(0.01)
        TT.toc("repeated")

    for i in range(3):
        time.sleep(0.01)
        TT.toc(f"unique {i+1}")

    print(TT)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    TimeTrain results:

    repeated : 0.01001968 s at file 10-TimeTrains.py line 73
    repeated : 0.01002906 s at file 10-TimeTrains.py line 73
    repeated : 0.01000689 s at file 10-TimeTrains.py line 73
    unique 1 : 0.01002947 s at file 10-TimeTrains.py line 77
    unique 2 : 0.01001701 s at file 10-TimeTrains.py line 77
    unique 3 : 0.01000890 s at file 10-TimeTrains.py line 77

    Total: 0.06011101 s





.. GENERATED FROM PYTHON SOURCE LINES 82-83

Timing measurements relative to identical names can be reduced using any reduction method in :data:`pyquickbench.all_reductions`.

.. GENERATED FROM PYTHON SOURCE LINES 83-99

.. code-block:: Python


    TT = pyquickbench.TimeTrain(
        names_reduction = 'sum',
    )

    for i in range(3):
        time.sleep(0.01)
        TT.toc("repeated")

    for i in range(3):
        time.sleep(0.01)
        TT.toc(f"unique {i+1}")

    print(TT)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /mnt/c/Users/gfo/Travail/Python/pyquickbench/pyquickbench/_time_train.py:106: UserWarning: include_locs and names_reduction were both enabled. Only the first location will be displayed for every name.
      warnings.warn("include_locs and names_reduction were both enabled. Only the first location will be displayed for every name.")
    TimeTrain results:
    Reduction: sum

    repeated : 0.03002766 s at file 10-TimeTrains.py line 90
    unique 1 : 0.01001109 s at file 10-TimeTrains.py line 94
    unique 2 : 0.01002195 s at file 10-TimeTrains.py line 94
    unique 3 : 0.01001639 s at file 10-TimeTrains.py line 94

    Total: 0.06007709 s





.. GENERATED FROM PYTHON SOURCE LINES 100-102

Reductions make locations ill-defined, which is why :class:`pyquickbench.TimeTrain` is issuing a warning. Another good reason to disable location recording is that the corresponding call to :func:`python:inspect.stack` can be non-negligible (around 0.01s on a generic laptop computer).
Displaying locations can be disabled like so:

.. GENERATED FROM PYTHON SOURCE LINES 102-119

.. code-block:: Python


    TT = pyquickbench.TimeTrain(
        names_reduction = 'sum',
        include_locs = False,
    )

    for i in range(3):
        time.sleep(0.01)
        TT.toc("repeated")

    for i in range(3):
        time.sleep(0.01)
        TT.toc(f"unique {i+1}")

    print(TT)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    TimeTrain results:
    Reduction: sum

    repeated : 0.03002848 s
    unique 1 : 0.01000969 s
    unique 2 : 0.01000530 s
    unique 3 : 0.01001121 s

    Total: 0.06005468 s





.. GENERATED FROM PYTHON SOURCE LINES 120-121

TimeTrains can also time calls to a function. The function :meth:`pyquickbench.TimeTrain.tictoc` will instrumemnt a given function to record its execution time. The most starightforward is to use :meth:`pyquickbench.TimeTrain.tictoc` with a decorator syntax:

.. GENERATED FROM PYTHON SOURCE LINES 121-138

.. code-block:: Python


    TT = pyquickbench.TimeTrain()

    @TT.tictoc
    def wait_a_bit():
        time.sleep(0.01)

    @TT.tictoc
    def wait_more():
        time.sleep(0.01)
    

    wait_a_bit()
    wait_more()

    print(TT)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    TimeTrain results:

    wait_a_bit : 0.01001038 s at file 10-TimeTrains.py line 133
    wait_more  : 0.01000896 s at file 10-TimeTrains.py line 134

    Total: 0.02001934 s





.. GENERATED FROM PYTHON SOURCE LINES 139-140

Using :meth:`pyquickbench.TimeTrain.tictoc` with a regular wrapping syntax might lead to surprizing results:

.. GENERATED FROM PYTHON SOURCE LINES 140-153

.. code-block:: Python

    
    TT = pyquickbench.TimeTrain()
    
    def wait_unrecorded():
        time.sleep(0.01)
    
    wait_recorded = TT.tictoc(wait_unrecorded)

    wait_unrecorded()
    wait_recorded()

    print(TT)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    TimeTrain results:

    wait_unrecorded : 0.01000667 s at file 10-TimeTrains.py line 149

    Total: 0.01000667 s





.. GENERATED FROM PYTHON SOURCE LINES 154-155

This behavior is to be expected because under the hood, :meth:`pyquickbench.TimeTrain.tictoc` uses the ``__name__`` attribute of the wrapped function. 

.. GENERATED FROM PYTHON SOURCE LINES 155-158

.. code-block:: Python

    
    print(f'{wait_recorded.__name__ = }')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    wait_recorded.__name__ = 'wait_unrecorded'




.. GENERATED FROM PYTHON SOURCE LINES 159-160

Overriding the ``__name__`` of the wrapped function gives the expected result:

.. GENERATED FROM PYTHON SOURCE LINES 160-173

.. code-block:: Python


    TT = pyquickbench.TimeTrain()
    
    def wait_unrecorded():
        time.sleep(0.01)
    
    wait_recorded = TT.tictoc(wait_unrecorded)
    wait_recorded.__name__ = 'wait_recorded'

    wait_unrecorded()
    wait_recorded()

    print(TT)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    TimeTrain results:

    wait_recorded : 0.01000844 s at file 10-TimeTrains.py line 170

    Total: 0.01000844 s





.. GENERATED FROM PYTHON SOURCE LINES 174-175

More simply, you can set a custom name with the following syntax:

.. GENERATED FROM PYTHON SOURCE LINES 175-188

.. code-block:: Python


    TT = pyquickbench.TimeTrain()
    
    def wait_unrecorded():
        time.sleep(0.01)
    
    wait_recorded = TT.tictoc(wait_unrecorded, name = "my_custom_name")

    wait_unrecorded()
    wait_recorded()

    print(TT)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    TimeTrain results:

    my_custom_name : 0.01001071 s at file 10-TimeTrains.py line 184

    Total: 0.01001071 s





.. GENERATED FROM PYTHON SOURCE LINES 189-190

By default, a :class:`pyquickbench.TimeTrain` will not show timings occuring in between decorated function. This behavior can be overriden setting the ``ignore_names`` argument to an empty iterator:

.. GENERATED FROM PYTHON SOURCE LINES 190-206

.. code-block:: Python


    TT = pyquickbench.TimeTrain(ignore_names = [])
    
    def wait_unrecorded():
        time.sleep(0.01)
    
    @TT.tictoc
    def wait_recorded():
        time.sleep(0.02)

    wait_unrecorded()
    wait_recorded()

    print(TT)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    TimeTrain results:

    pyquickbench_sync : 0.01001581 s at file 10-TimeTrains.py line 201
    wait_recorded     : 0.02000847 s at file 10-TimeTrains.py line 201

    Total: 0.03002428 s





.. GENERATED FROM PYTHON SOURCE LINES 207-209

Let's revisit the benchmark in :ref:`sphx_glr__build_auto_examples_tutorial_09-Vector_output.py` and measure the execution time of different parts of the function ``uniform_quantiles`` using :class:`pyquickbench.TimeTrain`.


.. GENERATED FROM PYTHON SOURCE LINES 209-227

.. code-block:: Python


    def uniform_quantiles(n, m):
   
        TT = pyquickbench.TimeTrain(
            include_locs = False,
        )
    
        vec = np.random.random((n+1))
        TT.toc("Random sampling")
    
        vec.sort()
        TT.toc("Sorting")
    
        res = np.array([abs(vec[(n // m)*i]) for i in range(m+1)])
        TT.toc("Building result")

        return TT








.. GENERATED FROM PYTHON SOURCE LINES 228-233

This function can be divided up into three main parts:

* A random sampling phase, where data is generated. This part is expected to scale as :math:`\mathcal{O}(n)`.
* A sorting phase where the random vector is sorted in-place. This part is expected to scale as :math:`\mathcal{O}(n\log(n))`, and thus be dominant for large :math:`n`.
* A last phase where estimated quantiles are built and returned. This phase is expected to scale as :math:`\mathcal{O}(1)` and be negligible for large :math:`n`.

.. GENERATED FROM PYTHON SOURCE LINES 234-264

.. code-block:: Python


    
    m = 10
    uniform_decile = functools.partial(uniform_quantiles, m=m)
    uniform_decile.__name__ = "uniform_decile"
    
    all_funs = [
        uniform_decile   ,   
    ]

    n_bench = 20
    all_sizes = [m * 2**n for n in range(n_bench)]

    n_repeat = 100
    
    plot_intent = {
        pyquickbench.default_ax_name : "points"         ,   
        pyquickbench.out_ax_name : "curve_color"        ,   
    }

    pyquickbench.run_benchmark(
        all_sizes                       ,
        all_funs                        ,
        n_repeat = n_repeat             ,
        mode = "vector_output"          ,
        StopOnExcept = True             ,
        plot_intent = plot_intent       ,
        show = True                     ,
    ) 




.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_10-TimeTrains_001.png
   :alt: 10 TimeTrains
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_10-TimeTrains_001.png
   :class: sphx-glr-single-img






.. _sphx_glr_download__build_auto_examples_tutorial_10-TimeTrains.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 10-TimeTrains.ipynb <10-TimeTrains.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 10-TimeTrains.py <10-TimeTrains.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: 10-TimeTrains.zip <10-TimeTrains.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
