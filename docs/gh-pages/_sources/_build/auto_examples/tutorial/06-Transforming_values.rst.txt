
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "_build/auto_examples/tutorial/06-Transforming_values.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download__build_auto_examples_tutorial_06-Transforming_values.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr__build_auto_examples_tutorial_06-Transforming_values.py:


Transforming values
===================

.. GENERATED FROM PYTHON SOURCE LINES 7-9

Let's expand on the benchmark exposed in :ref:`sphx_glr__build_auto_examples_tutorial_03-Preparing_inputs.py`.
The benchmark consists in understanding the convergence behavior of the following ODE integrators provided by :mod:`scipy:scipy`.

.. GENERATED FROM PYTHON SOURCE LINES 9-34

.. code-block:: Python


    method_names = [
        "RK45"  ,  
        "RK23"  ,  
        "DOP853",  
        "Radau" ,  
    ]


    plot_ylim = [1e-17, 1e1]

    bench_filename = os.path.join(bench_folder,basename_bench_filename+'_error.npz')

    pyquickbench.run_benchmark(
        all_nint                        ,
        bench                           ,
        mode = "scalar_output"          ,
        filename = bench_filename       ,
        plot_ylim = plot_ylim                       ,
        title = f'Relative error on integrand'      ,
        ylabel = "Relative error"   ,
        show = True                                 ,
    )





.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_001.png
   :alt: Relative error on integrand
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 132-133

A natural question in this case is to ask whether the measured convergence rates of the numerical methods match their theoretical convergence rates. This post-processing can be performed automatically by :func:`pyquickbench.run_benchmark` if the argument ``transform`` is set to ``"pol_cvgence_order"``.

.. GENERATED FROM PYTHON SOURCE LINES 133-149

.. code-block:: Python


    plot_ylim = [0, 10]

    pyquickbench.run_benchmark(
        all_nint                                ,
        bench                                   ,
        mode = "scalar_output"                  ,
        filename = bench_filename               ,
        plot_ylim = plot_ylim                   ,
        ylabel = "Measured convergence rate"    ,
        show = True                             ,
        logx_plot = True                        ,
        transform = "pol_cvgence_order"         ,
    )





.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_002.png
   :alt: 06 Transforming values
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 150-151

The pre and post convergence behavior of the numerical algorithms really clutters the plots. In this case, a clearer plot is obtained if the argument ``clip_vals`` is set to ``True``.

.. GENERATED FROM PYTHON SOURCE LINES 151-165

.. code-block:: Python


    pyquickbench.run_benchmark(
        all_nint                                ,
        bench                                   ,
        mode = "scalar_output"                  ,
        filename = bench_filename               ,
        plot_ylim = plot_ylim                   ,
        ylabel = "Measured convergence rate"    ,
        show = True                             ,
        logx_plot = True                        ,
        transform = "pol_cvgence_order"         ,
        clip_vals = True                        ,
    )




.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_003.png
   :alt: 06 Transforming values
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 166-167

The measured values can now be compared to the theoretical convergence rates of the different methods. In order to plot your own data to the figure, you can handle the :class:`matplotlib:matplotlib.figure.Figure` and :class:`matplotlib:matplotlib.axes.Axes` objects yourself, And decoupe the calls to :func:`pyquickbench.run_benchmark` and :func:`pyquickbench.plot_benchmark` as shown here.

.. GENERATED FROM PYTHON SOURCE LINES 167-216

.. code-block:: Python


    bench_results = pyquickbench.run_benchmark(
        all_nint                                ,
        bench                                   ,
        mode = "scalar_output"                  ,
        filename = bench_filename               ,
    )

    th_cvg_rate = {
        "RK45"  : 5,  
        "RK23"  : 3,  
        "DOP853": 8,  
        "Radau" : 5, 
    }

    fig, ax = plt.subplots(
        nrows = 1                       ,
        ncols = 1                       ,
        figsize = (1600/150, 800/150)   ,
        dpi = 150                       ,
        squeeze = False                 ,
    )

    pyquickbench.plot_benchmark(
        bench_results                           ,
        all_nint                                ,
        bench                                   ,
        mode = "scalar_output"                  ,
        fig = fig                               ,
        ax = ax                                 ,
        plot_ylim = plot_ylim                   ,
        ylabel = "Measured convergence rate"    ,
        logx_plot = True                        ,
        transform = "pol_cvgence_order"         ,
        clip_vals = True                        ,
    )


    xlim = ax[0,0].get_xlim()
    for name in bench:
        
        th_order = th_cvg_rate[name]
        ax[0,0].plot(xlim, [th_order, th_order], linestyle='dotted')

    ax[0,0].set_xlim(xlim)
    plt.tight_layout()
    plt.show()





.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_004.png
   :alt: 06 Transforming values
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 217-218

Similarly we can check that the integrations algorithms provided by :mod:`scipy:scipy` scale linearly with respect to the number of integrations steps with the ``transform`` argument set to ``"pol_growth_order"``:

.. GENERATED FROM PYTHON SOURCE LINES 218-229

.. code-block:: Python


    timings_filename = os.path.join(bench_folder,basename_bench_filename+'_timings.npz') 

    pyquickbench.run_benchmark(
        all_nint                                    ,
        bench                                       ,
        filename = timings_filename                 ,
        logx_plot = True                            ,
        title = "Computational cost growth order"   ,
        transform = "pol_growth_order"              ,
        show = True                                 ,
    )


.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_005.png
   :alt: Computational cost growth order
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_005.png
   :class: sphx-glr-single-img






.. _sphx_glr_download__build_auto_examples_tutorial_06-Transforming_values.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 06-Transforming_values.ipynb <06-Transforming_values.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 06-Transforming_values.py <06-Transforming_values.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
