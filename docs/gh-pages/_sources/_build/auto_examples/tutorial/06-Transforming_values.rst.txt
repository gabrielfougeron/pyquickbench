
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "_build/auto_examples/tutorial/06-Transforming_values.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download__build_auto_examples_tutorial_06-Transforming_values.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr__build_auto_examples_tutorial_06-Transforming_values.py:


Plotting transformed values
===========================

.. GENERATED FROM PYTHON SOURCE LINES 7-9

Let's expand on the benchmark exposed in :ref:`sphx_glr__build_auto_examples_tutorial_05-Plotting_scalars.py`.
The benchmark consists in understanding the convergence behavior of the following ODE integrators provided by :mod:`scipy:scipy`.

.. GENERATED FROM PYTHON SOURCE LINES 9-18

.. code-block:: Python


    method_names = [
        "RK45"  ,  
        "RK23"  ,  
        "DOP853",  
        "Radau" ,  
    ]









.. GENERATED FROM PYTHON SOURCE LINES 112-113

Let's focus on timings first.

.. GENERATED FROM PYTHON SOURCE LINES 113-128

.. code-block:: Python

    timings_filename = os.path.join(bench_folder,basename_bench_filename+'_timings.npz') 
    timings_results = pyquickbench.run_benchmark(
        all_nint                                    ,
        bench                                       ,
        filename = timings_filename                 ,
    )

    pyquickbench.plot_benchmark(
        timings_results                 ,
        all_nint                        ,
        bench                           ,
        show = True                     ,
        title = 'Computational cost'    , 
    )




.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_001.png
   :alt: Computational cost
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 129-130

We can check that the integrations algorithms provided by :mod:`scipy:scipy` scale linearly with respect to the number of integrations steps with the ``transform`` argument set to ``"pol_growth_order"``:

.. GENERATED FROM PYTHON SOURCE LINES 130-141

.. code-block:: Python


    pyquickbench.plot_benchmark(
        timings_results                             ,
        all_nint                                    ,
        bench                                       ,
        logx_plot = True                            ,
        title = "Computational cost growth order"   ,
        transform = "pol_growth_order"              ,
        show = True                                 ,
    )




.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_002.png
   :alt: Computational cost growth order
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 142-143

Since all the functions in the benchmark have the same asymptotic behavior, it makes sense to compare then against each other. Let's pick a reference method, for instance "DOP853" and plot all timings relative to this reference. This is achieved with the ``relative_to_val`` argument.

.. GENERATED FROM PYTHON SOURCE LINES 143-156

.. code-block:: Python


    relative_to_val = {pyquickbench.fun_ax_name: "DOP853"}

    pyquickbench.plot_benchmark(
        timings_results                         ,
        all_nint                                ,
        bench                                   ,
        logx_plot = True                        ,
        title = "Relative computational cost"   ,
        relative_to_val = relative_to_val       ,
        show = True                             ,
    )




.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_003.png
   :alt: Relative computational cost
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 157-158

Let's focus on accuracy measurements now.

.. GENERATED FROM PYTHON SOURCE LINES 158-179

.. code-block:: Python


    plot_ylim = [1e-17, 1e1]
    scalar_filename = os.path.join(bench_folder,basename_bench_filename+'_error.npz')
    bench_results = pyquickbench.run_benchmark(
        all_nint                                ,
        bench                                   ,
        mode = "scalar_output"                  ,
        filename = scalar_filename               ,
    )

    pyquickbench.plot_benchmark(
        bench_results                           ,
        all_nint                                ,
        bench                                   ,
        mode = "scalar_output"                  ,
        plot_ylim = plot_ylim                   ,
        title = 'Relative error on integrand'  ,
        ylabel = "Relative error"               ,
        show = True                             ,
    )




.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_004.png
   :alt: Relative error on integrand
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 180-181

A natural question when assessing accuracy is to ask whether the measured convergence rates of the numerical methods match their theoretical convergence rates. This post-processing can be performed automatically by :func:`pyquickbench.run_benchmark` if the argument ``transform`` is set to ``"pol_cvgence_order"``.

.. GENERATED FROM PYTHON SOURCE LINES 181-197

.. code-block:: Python


    plot_ylim = [0, 10]

    pyquickbench.plot_benchmark(
        bench_results                           ,
        all_nint                                ,
        bench                                   ,
        mode = "scalar_output"                  ,
        plot_ylim = plot_ylim                   ,
        ylabel = "Measured convergence rate"    ,
        logx_plot = True                        ,
        transform = "pol_cvgence_order"         ,
        show = True                             ,
    )





.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_005.png
   :alt: 06 Transforming values
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 198-199

The pre and post convergence behavior of the numerical algorithms really clutters the plots. In this case, a clearer plot is obtained if the argument ``clip_vals`` is set to ``True``.

.. GENERATED FROM PYTHON SOURCE LINES 199-213

.. code-block:: Python


    pyquickbench.plot_benchmark(
        bench_results                           ,
        all_nint                                ,
        bench                                   ,
        mode = "scalar_output"                  ,
        plot_ylim = plot_ylim                   ,
        ylabel = "Measured convergence rate"    ,
        logx_plot = True                        ,
        transform = "pol_cvgence_order"         ,
        clip_vals = True                        ,
        show = True                             ,
    )




.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_006.png
   :alt: 06 Transforming values
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 214-215

The measured values can now be compared to the theoretical convergence rates of the different methods. In order to plot your own data to the figure, you can handle the :class:`matplotlib:matplotlib.figure.Figure` and :class:`matplotlib:matplotlib.axes.Axes` objects yourself, And decouple the calls to :func:`pyquickbench.run_benchmark` and :func:`pyquickbench.plot_benchmark` as shown here.

.. GENERATED FROM PYTHON SOURCE LINES 215-246

.. code-block:: Python


    th_cvg_rate = {
        "RK45"  : 5,  
        "RK23"  : 3,  
        "DOP853": 8,  
        "Radau" : 5, 
    }

    fig, ax = pyquickbench.plot_benchmark(
        bench_results                           ,
        all_nint                                ,
        bench                                   ,
        mode = "scalar_output"                  ,
        show = False                            ,
        plot_ylim = plot_ylim                   ,
        ylabel = "Measured convergence rate"    ,
        logx_plot = True                        ,
        transform = "pol_cvgence_order"         ,
        clip_vals = True                        ,
    )

    xlim = ax[0,0].get_xlim()
    for name in bench:
        
        th_order = th_cvg_rate[name]
        ax[0,0].plot(xlim, [th_order, th_order], linestyle='dotted')

    ax[0,0].set_xlim(xlim)
    plt.tight_layout()
    plt.show()




.. image-sg:: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_007.png
   :alt: 06 Transforming values
   :srcset: /_build/auto_examples/tutorial/images/sphx_glr_06-Transforming_values_007.png
   :class: sphx-glr-single-img






.. _sphx_glr_download__build_auto_examples_tutorial_06-Transforming_values.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 06-Transforming_values.ipynb <06-Transforming_values.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 06-Transforming_values.py <06-Transforming_values.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: 06-Transforming_values.zip <06-Transforming_values.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
